#include<stdio.h>
#include<time.h>
#include<stdlib.h>
/////void printarr(int arr[],int len);
/////int add(int arr[], int num1, int len);
/////int add1(int arr[], int num, int len);
//函数：函数就是程序中独立的功能。
//void 函数名（）
//{
//	函数体；
//}
//带参数的函数：函数名()
//void 函数名（形参1，）
//{
//	函数体；
//}//形参和实参必须一一对应
//#include<stdio.h>
//void add(int num1, int num2)
//{
//	int sum = num1 + num2;
//	printf("%d", sum);
//}要写在int main()之前

//int sum(int num1, int num2)//int 返回值类型
//{
//	int sum = num1 + num2;
//	return sum;
//}return作用：1.结束函数。
//2.把后面的数据，交给调用处。（x）
//格式：返回值类型 函数名（形参1，）
//{
//	函数体；
//	return 返回值；
//}
//int main()
//{
	/*int a = sum(10, 20);//(x)
	int b = sum(11, 18);*/
//	函数的注意事项:
//1.函数不调用就不执行
//2.函数名不能重复	
//3。函数与函数之间是平级关系，不能嵌套定义	
//4，自定义函数写在main函数的下面，需要在上方申明	
//5，return下面，不能编写代码，永远执行不到，属于无效的代码	
//6，函数的返回值类型为void，表示没有返回值，return可以省略不写	
//如果书写了return，后面不能跟具体的数据，仅表示结束函数

//<math.h>
//pow(2,3)=8幂
//sqrt()平方根，ceil()向上取整，abs()绝对值
//<time.h>获取当前时间
	//time()获取当前时间
	//形参:表示获取的当前时间是否需要在其他地方进行存储
//一般来讲，不需要在其他地方进行存储的，NULL(大写)
//返回值:long long//结果是什么呢?
// 从1970年1月1日0:0:0开始过了1709817925秒的那个时间点
	/*long long res = time(NULL);
	printf("%lld", res);*/

	//随机数<stdlib.h> srand()设置种子 rand()获取随机数
	//srand(1);//初始值，因为每一个随机数是通过前一个数字结合一系列复杂计算得到的
	//for (int i = 0; i < 8; i++)
	//{
	//	int num = rand();
	//	printf("%d\n", num);
	//}
//随机数的两个小弊端:
//1.种子不变，随机数结果是固定的
//2.随机数的范围	
//默认范围:0~32767	
//任意的范围之内获取一个随机数:
//绝招:用于生成任意范围之内的随机数
//1.把这个范围变成包头不包尾，包左不包右的1~101
//2.拿着尾巴开头101-1=100
//3.修改代码

	//1.设置种子 不能固定不变，不然结果不变 用一个变化数据充当种子 时间
	//srand(time(NULL));
	//for (int i = 0; i < 100; i++)
	//{
	//	int num = rand() % 100 + 1;//表示1-100之间随机数
	//	printf("%d\n", num);
	//}

	//数组:是一种容器，可以用来存储同种数据类型的多个值
	//数据类型 数组名[长度] int arr[3]
//特点1:连续的空间
//特点2 : 一旦定义，长度不可变
	//1，定义数组存储5个学生的年龄，并初始化。2，定义数组存储你女朋友的身高，并初始化。
//数组的定义并初始化的格式:
// 	数据类型 数组名[长度]={数据1，数据2...}:	
// 	细节1:	
// 	如果数组的长度没有写，数据值的个数就是数组的长度	
// 	细节2:	
// 	如果数组的长度已经写上，数据值的个数<=长度	
// 	未赋值的部分有默认值	
// 	整数:0	
// 	小数:0.0	
// 	字符:'\0'
// 	字符串:NULL(什么都没有)
//遍历：依次获取数组中的每一个元素
	//内存地址：编号
	//内存:软件在运行时，用来临时存储数据的
	//1.是把数据保存到内存中	2.从内存的「对应位置」把数据取出来
//内存地址:内存中每一个小格子的编号
//作用:快速的管理内存空间
//32位系统:以32位的二进制表示
//64位系统:以64位的二进制表示
//首地址：第一个小格子
	//int a = 10;
	//printf("%p", &a);//%p获取变量的内存地址：&变量名
	//首地址[索引] arr[2] arr:0x0001;
	//偏移量2为偏移两个单位
//1. 通过变量的首地址，就可以确定变量中存储的数据
//3.数组的长度如何计算
//公式:总长度/数据类型占用的字节个数
//1.数组作为函数的参数，要注意什么?
//实际上传递是数组的首地址，如果要在函数中对数组进行遍历的话，记得一定要把数组的长度一起传递过去
//定义处:arr表示的就是完整的数组
//函数中的arr: 只是一个变量，用来记录数组的首地址
//2.数组的索引越界
//最小索引:0
//最大索引:长度-1
	/*int arr[] = { 1,2,3,4,5 };
	int len = sizeof(arr) / sizeof(int);
	printarr(arr, len);*/
	//基本查找
	/*int arr[] = { 11,22,44,45,67,78 };
	int len = sizeof(arr) / sizeof(int);
	int num1 = 22;
	int a = add(arr, num1, len);
	printf("%d", a);*///函数部分见第五行
	//二分查找
	/*int arr[] = { 12,23,34,45,66,78 };
	int num = 24;
	int len = sizeof(arr) / sizeof(int);
	int zhi = add1(arr, num, len);
	printf("%d", zhi);*////函数部分见第六行
//1. 二分查找的优势?
//提前查找效率
//2.二分查找的前提条件?
//数据必须是有序的
//如果数据是乱的，先排序再用二分查找得到的索引没有实际意义，
//只能确定当前数字在数组中是否存在，因为排序之后数字的位置就可能发生变化了
//3.二分查找的过程
//min和max表示当前要查找的范围 mid是在min和max中间的
//如果要查找的元素在mid的左边，缩小范围时，min不变，max等于mid减1
//如果要查找的元素在mid的右边，缩小范围时，max不变，min等于mid加1
    //分段查找
	//mid = min + (key-arr[min])/(arr[max]-arr[min])*(max-min);
	// 要求:数据要有序，且数据分布尽可能的均匀一点
	// 分块的原则1:前一块中的最大数据，小于后一块中所有的数据(块内无序，块间有序)
//分块的原则2:块数数量一般等于数字的个数开根号。比如:16个数字一般分为4块左右。
//核心思路:先确定要查找的元素在哪一块，然后在块内挨个查找。
//优势:满足要求，效率比二分查找快，否则反而会更慢
    //选择排序
    /*int arr[] = { 2,3,5,4,1 };
	int len = sizeof(arr) / sizeof(int);
	for (int i = 0; i < len; i++)
	{
		for (int j = i + 1; j < len; j++)
		{
			if (arr[i] > arr[j])
			{
				int temp = arr[i];
				arr[i] = arr[j];
				arr[j] = temp;
			}
		}
	}
	for (int k = 0; k < len; k++)
	{
		printf("%d", arr[k]);
	}*/
//冒泡排序
// 1，相邻的元素两两比较，大的放右边，小的放左边。
//2，第一轮比较完毕之后，最大值就已经确定，第二轮可以少循环一次，后面以此类推。
//3，如果数组中有n个数据，总共我们只要执行n-1轮的代码就可以。 

//2.利用冒泡排序，把数组中的数据按照升序排列 
// 双重循环本质:就是把内循环重复执行了N次而已
// 首先看内循环的作用
// 内循环:找到本次循环的较大值，再把较大值放到了最右边
// 外循环:把上面的这个动作重复执行了4次
//int arr[] = { 2,3,5,4,1 };
//int len = sizeof(arr) / sizeof(int);
//for (int i = 0; i < len - 1; i++)
//{
//	for (int j = 0; j < len -1 - i; j++)
//	{
//		if (arr[j] > arr[j + 1])
//		{
//			int temp = arr[j];
//			arr[j] = arr[j + 1];
//			arr[j + 1] = temp;
//		}
//	}
//}
//for (int k = 0; k < len; k++)
//{
//	printf("%d", arr[k]);
//}

//    return 0;
//}
//void printarr(int arr[],int len)
//{
//	printf("%zu\n", sizeof(arr));//8 64位的操作系统当中，是以64个二进制表示内存地址值
//	for (int i = 0; i < len; i++)
//	{
//		printf("%d\n", arr[i]);
//	}
//}
//int add(int arr[], int num1,int len)
//{
//	for (int i = 0; i < len; i++)
//	{
//		if (num1 == arr[i])
//		{
//			return i;
//		}
//	}
//	return -1;
// 作用:利用二分查找法查找数据
//	返回值:数据在数组中的索引
//	找到了，真实的索引
// 没有找到，返回-1
//}
//int add1(int arr[], int num, int len)
//{
//	int min = 0;
//	int max = len - 1;
//	
//	while (min <= max)
//	{
//		int mid = (min + max) / 2;
//		if (arr[mid] < num)
//		{
//			min = mid + 1;
//		}
//		else if (arr[mid] > num)
//		{
//			max = mid - 1;
//		}
//		else
//		{
//			return mid;
//		}
//	}
//	return -1;
//}